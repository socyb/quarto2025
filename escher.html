<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escher - Escaleras Imposibles Animadas</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.5.2/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.5.2/core.js"></script>
    <style>
        /* Ocultar la terminal de PyScript por defecto */
        py-terminal {
            position: fixed !important;
            bottom: -300px !important;
            left: 0 !important;
            right: 0 !important;
            height: 300px !important;
            transition: bottom 0.3s ease !important;
            z-index: 9999 !important;
            background: rgba(0, 0, 0, 0.95) !important;
            border-top: 2px solid #8b5cf6 !important;
        }
        
        py-terminal.show {
            bottom: 0 !important;
        }
        
        #toggle-terminal {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
            transition: all 0.3s ease;
        }
        
        #toggle-terminal:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.6);
        }
        
        #toggle-terminal:active {
            transform: translateY(0);
        }
    </style>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000000;
            font-family: 'Arial', sans-serif;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        svg {
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
        }
        
        .title-overlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            z-index: 1000;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.7);
            padding: 0 20px;
        }
        
        .title-overlay h1 {
            font-size: clamp(1.5rem, 5vw, 3rem);
            font-weight: 800;
            margin-bottom: 0.5rem;
        }
        
        .title-overlay p {
            font-size: clamp(0.9rem, 2vw, 1.2rem);
            opacity: 0.9;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .fade-in {
            animation: fadeIn 1s ease-in;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .title-overlay {
                top: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="title-overlay fade-in">
        <h1>üî∑ Escalera de Penrose - Estilo Escher üî∑</h1>
        <p>Geometr√≠a Imposible en Movimiento</p>
    </div>
    
    <button id="toggle-terminal" onclick="toggleTerminal()">üñ•Ô∏è Console</button>
    
    <div id="canvas-container">
        <svg id="escher-canvas" viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid meet">
            <!-- El SVG ser√° generado por PyScript -->
        </svg>
    </div>
    
    <div id="loading" class="loading">Cargando PyScript...</div>
    
    <script>
        function toggleTerminal() {
            const terminal = document.querySelector('py-terminal');
            if (terminal) {
                terminal.classList.toggle('show');
            }
        }
    </script>
    
    <script type="py" terminal>
from js import document, setInterval
import math

# Configuraci√≥n
class EscherArt:
    def __init__(self):
        self.svg = document.getElementById('escher-canvas')
        self.angle = 0
        self.colors = [
            '#8b5cf6', '#a78bfa', '#c4b5fd', '#ddd6fe',
            '#6366f1', '#818cf8', '#a5b4fc', '#c7d2fe'
        ]
        self.animation_speed = 0.02
        self.scale_factor = 1.0
        print("EscherArt inicializado")
        
    def clear_svg(self):
        """Limpia el contenido del SVG"""
        self.svg.innerHTML = ''
        
    def create_rect(self, x, y, width, height, fill, opacity=1, transform=''):
        """Crea un rect√°ngulo SVG"""
        rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
        rect.setAttribute('x', str(x))
        rect.setAttribute('y', str(y))
        rect.setAttribute('width', str(width))
        rect.setAttribute('height', str(height))
        rect.setAttribute('fill', fill)
        rect.setAttribute('opacity', str(opacity))
        if transform:
            rect.setAttribute('transform', transform)
        return rect
        
    def create_polygon(self, points, fill, opacity=1, stroke='none', stroke_width=0):
        """Crea un pol√≠gono SVG"""
        poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon')
        points_str = ' '.join([f"{x},{y}" for x, y in points])
        poly.setAttribute('points', points_str)
        poly.setAttribute('fill', fill)
        poly.setAttribute('opacity', str(opacity))
        poly.setAttribute('stroke', stroke)
        poly.setAttribute('stroke-width', str(stroke_width))
        return poly
        
    def create_path(self, d, fill='none', stroke='black', stroke_width=2, opacity=1):
        """Crea un path SVG"""
        path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
        path.setAttribute('d', d)
        path.setAttribute('fill', fill)
        path.setAttribute('stroke', stroke)
        path.setAttribute('stroke-width', str(stroke_width))
        path.setAttribute('opacity', str(opacity))
        return path
        
    def create_penrose_stairs(self):
        """Crea la escalera de Penrose (escalera imposible)"""
        center_x, center_y = 500, 500
        size = 300
        
        # Definir los 4 segmentos de la escalera imposible
        stairs = []
        
        # Segmento 1 (parte superior izquierda)
        stairs.append([
            (center_x - size/2, center_y - size/2),
            (center_x, center_y - size/2),
            (center_x, center_y - size/4),
            (center_x - size/4, center_y - size/4)
        ])
        
        # Segmento 2 (parte superior derecha)
        stairs.append([
            (center_x, center_y - size/2),
            (center_x + size/2, center_y - size/2),
            (center_x + size/4, center_y),
            (center_x, center_y - size/4)
        ])
        
        # Segmento 3 (parte inferior derecha)
        stairs.append([
            (center_x + size/4, center_y),
            (center_x + size/2, center_y - size/2),
            (center_x + size/2, center_y + size/2),
            (center_x, center_y + size/4)
        ])
        
        # Segmento 4 (parte inferior izquierda)
        stairs.append([
            (center_x - size/2, center_y - size/2),
            (center_x - size/4, center_y - size/4),
            (center_x, center_y + size/4),
            (center_x - size/2, center_y + size/2)
        ])
        
        return stairs
        
    def create_tessellation(self):
        """Crea un patr√≥n de teselaci√≥n estilo Escher"""
        patterns = []
        grid_size = 8
        cell_size = 1000 / grid_size
        
        for row in range(grid_size):
            for col in range(grid_size):
                x = col * cell_size
                y = row * cell_size
                
                # Alternar patrones
                if (row + col) % 2 == 0:
                    # Rombo
                    points = [
                        (x + cell_size/2, y),
                        (x + cell_size, y + cell_size/2),
                        (x + cell_size/2, y + cell_size),
                        (x, y + cell_size/2)
                    ]
                    color = self.colors[(row + col) % len(self.colors)]
                    patterns.append((points, color, 0.3))
                
        return patterns
        
    def create_impossible_cube(self, x, y, size, rotation):
        """Crea un cubo imposible (Necker cube)"""
        s = size
        r = rotation
        
        # Calcular v√©rtices con rotaci√≥n
        cos_r = math.cos(r)
        sin_r = math.sin(r)
        
        # V√©rtices del cubo frontal
        front = [
            (x - s*cos_r, y - s*sin_r),
            (x + s*cos_r, y - s*sin_r),
            (x + s*cos_r, y + s*sin_r),
            (x - s*cos_r, y + s*sin_r)
        ]
        
        # V√©rtices del cubo trasero (desplazado)
        offset_x = s * 0.4 * cos_r
        offset_y = -s * 0.4
        back = [
            (front[0][0] + offset_x, front[0][1] + offset_y),
            (front[1][0] + offset_x, front[1][1] + offset_y),
            (front[2][0] + offset_x, front[2][1] + offset_y),
            (front[3][0] + offset_x, front[3][1] + offset_y)
        ]
        
        return front, back
        
    def draw_frame(self):
        """Dibuja un frame de la animaci√≥n"""
        self.clear_svg()
        
        # Fondo con patr√≥n de teselaci√≥n
        tessellation = self.create_tessellation()
        for points, color, opacity in tessellation:
            poly = self.create_polygon(points, color, opacity)
            self.svg.appendChild(poly)
        
        # Dibujar m√∫ltiples cubos imposibles rotando
        cube_positions = [
            (250, 250, 80),
            (750, 250, 80),
            (250, 750, 80),
            (750, 750, 80),
            (500, 500, 120)
        ]
        
        for i, (cx, cy, size) in enumerate(cube_positions):
            rotation = self.angle + i * math.pi / 4
            front, back = self.create_impossible_cube(cx, cy, size, rotation)
            
            # Dibujar caras del cubo
            color_idx = i % len(self.colors)
            
            # Cara frontal
            front_poly = self.create_polygon(front, self.colors[color_idx], 0.7, 'white', 3)
            self.svg.appendChild(front_poly)
            
            # Cara trasera
            back_poly = self.create_polygon(back, self.colors[(color_idx+1) % len(self.colors)], 0.5, 'white', 2)
            self.svg.appendChild(back_poly)
            
            # Conectar v√©rtices para crear efecto 3D
            for j in range(4):
                path_d = f"M {front[j][0]} {front[j][1]} L {back[j][0]} {back[j][1]}"
                path = self.create_path(path_d, stroke='white', stroke_width=2, opacity=0.6)
                self.svg.appendChild(path)
        
        # Dibujar escalera de Penrose en el centro con rotaci√≥n
        stairs = self.create_penrose_stairs()
        
        for i, stair_points in enumerate(stairs):
            # Aplicar rotaci√≥n a los puntos
            rotated_points = []
            for px, py in stair_points:
                # Rotar alrededor del centro
                dx = px - 500
                dy = py - 500
                cos_a = math.cos(self.angle)
                sin_a = math.sin(self.angle)
                new_x = dx * cos_a - dy * sin_a + 500
                new_y = dx * sin_a + dy * cos_a + 500
                rotated_points.append((new_x, new_y))
            
            # Crear gradiente de color basado en el √°ngulo
            color_idx = (i + int(self.angle * 10)) % len(self.colors)
            poly = self.create_polygon(
                rotated_points,
                self.colors[color_idx],
                0.9,
                'white',
                3
            )
            self.svg.appendChild(poly)
        
        # Actualizar √°ngulo para la siguiente frame
        self.angle += self.animation_speed
        if self.angle > 2 * math.pi:
            self.angle = 0

# Inicializar y comenzar animaci√≥n
print("Iniciando animaci√≥n...")
escher = EscherArt()

# Ocultar mensaje de carga
loading_div = document.getElementById('loading')
if loading_div:
    loading_div.style.display = 'none'

# Dibujar primer frame
escher.draw_frame()
print("Primer frame dibujado")

# Funci√≥n de animaci√≥n usando proxy
from pyodide.ffi import create_proxy

def animate():
    try:
        escher.draw_frame()
    except Exception as e:
        print(f"Error en animaci√≥n: {e}")

# Crear proxy para la funci√≥n
animate_proxy = create_proxy(animate)

# Iniciar animaci√≥n
print("Configurando intervalo...")
interval_id = setInterval(animate_proxy, 50)  # 20 FPS
print("Animaci√≥n iniciada!")
    </script>
</body>
</html>
